//基础题意是 给出一个n*m的矩阵 由0 1 组成 把矩阵中的每个子正方形里的1的个数变为奇数的最小值（1变为0，0变为1 各+1）
//先由推导可得出 n >= 4 && m >= 4 的时候不存在 因为由4个2 * 2的大小组成的正方形 应该是4个奇数相加为偶数 所以不存在；
/*1.n == 1 的时候输出0；
  2. n == 2 的时候 只需要看两行 所以第一列为奇 第二列为偶 这样就可以形成一个 或者 第一列为偶 第二列为奇 又可以形成一个 取最小值就行；
  3. n == 3 的时候 就是一个经典的模型了 玉米田模型 把左右两列 符合条件的预处理出来 然后dp求最小值即可 */


#include<iostream>
#include<vector>
#include<cstring> 

using namespace std;

const int N = 1e6 + 10;
string a[5];string c;
int b[5][N],dp[N][16];
int n,m;
vector<int>state[16];

bool check(int x,int y){
	int a1 = x >> 0 & 1,a2 = x >> 1 & 1,a3 = x >> 2 & 1;
	int b1 = y >> 0 & 1,b2 = y >> 1 & 1,b3 = y >> 2 & 1;
	if(((a1 + b1 + a2 + b2) & 1) == 0) return false;
	if(((a2 + a3 + b2 + b3) & 1) == 0) return false;
	return true;
}

int cal(int lie,int state){
	int sum = 0;
	int a1 = b[1][lie],a2 = b[2][lie],a3 = b[3][lie];
	int b1 = state >> 2 & 1,b2 = state >> 1 & 1,b3 = state >> 0 & 1;
	if(a1 != b1) sum++;
	if(a2 != b2) sum++;
	if(a3 != b3) sum++;
	return sum; 
}

int main(){
	int n,m;
	cin >> n >> m;
	if(n > 3){
		for(int i = 0; i < n; i++){
			cin >> c;
		}
	}else{
		for(int i = 0; i < n; i++){
			cin >> a[i];
			for(int j = 0; j < m; j++){
				b[i + 1][j + 1] = a[i][j] - '0';
			}
		}
	}
	
	if(n > 3 && m > 3){
		cout << -1 << endl;
		return 0;	
	}
	if(n == 1) {
		cout << 0 << endl;
		return 0;
	}
	
	if(n == 2){
		//奇偶 
		int ans1 = 0,ans2 = 0;
		for(int i = 1; i <= m; i++){
			if(b[1][i] ^ b[2][i] != (i % 2)){
				ans1++;
			}
		}
		for(int i = 1; i <= m; i++){
			if(b[1][i] ^ b[2][i] != ((i - 1) % 2)){
				ans2++;
			}
		}
		cout << min(ans1,ans2) << endl;
	}else{
		memset(dp,0x3f,sizeof dp);
		for(int i = 0; i < 1 << 3; i++){
			for(int j = 0; j < 1 << 3; j++){
				if(check(i,j)) state[i].push_back(j);
			}
		}
		
		for(int i = 0; i < 1 << 3; i++){
			dp[1][i] = min(dp[1][i],cal(1,i));
		}
		
		for(int i = 2; i <= m; i++){
			for(int j = 0; j < 1 << 3; j++){
				for(int k = 0; k < state[j].size(); k++){
					dp[i][state[j][k]] = min(dp[i][state[j][k]],dp[i - 1][j] + cal(i,state[j][k]));
				}
			}
		}
		
		int minn = 0x3f3f3f3f;
		for(int i = 0; i < 1 << 3; i++){
			minn = min(minn,dp[m][i]);
		}
		
		cout << minn << endl;
	}
	
	return 0;
}
