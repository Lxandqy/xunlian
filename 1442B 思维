//1 2 3 4 5
// 1 3 5 
// 1可由删除2得 1向右补充2得空位 并且1可以用  所以3可由 1 4 得  3用掉4可以向右补充4的存在 所以无论是谁用掉了 都可以补充这个的位置 所以无所谓谁用 就看周围的点是否可用


#include<iostream>
#include<map>
#include<cstring>

using namespace std;

const int N = 200010,mod = 998244353;
int a[N],flag[N],b[N];
map<int,int>mp;

int main(){
	int t;
	cin >> t;
	while(t--){
		int n,m;
		scanf("%d%d",&n,&m);
		for(int i = 1; i <= n; i++){
			scanf("%d",&a[i]);
			mp[a[i]] = i;
		}
		
		for(int i = 1; i <= m; i++){
			scanf("%d",&b[i]);
			flag[b[i]] = 1;
		}
		
		long long  ans = 1;
		for(int i = 1; i <= m; i++){
			int sum = 0;
			if(!flag[a[mp[b[i]] - 1]] && mp[b[i]] - 1 >= 1) sum++;
			if(!flag[a[mp[b[i]] + 1]] && mp[b[i]] + 1 <= n) sum++;
			if(sum == 0){
				ans = 0;
			}else{
				ans = ans * sum % mod;
			}
			flag[a[mp[b[i]]]] = 0;
			mp[b[i]] = 0;
		}
		
		printf("%lld\n",ans);
	}
	
	return 0;
}
